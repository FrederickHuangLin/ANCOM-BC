mds.xy.uq2=mds.xy.uq2%>%mutate(scale_x1=scale(X1), scale_x2=scale(X2))
mds.xy.tmm2=mds.xy.tmm2%>%mutate(scale_x1=scale(X1), scale_x2=scale(X2))
mds.xy.tss=mds.xy.tss%>%mutate(scale_x1=scale(X1), scale_x2=scale(X2))
mds.list=list(mds.xy.ancom.bc, mds.xy.uq1, mds.xy.tmm1, mds.xy.css,
mds.xy.med, mds.xy.uq2, mds.xy.tmm2, mds.xy.tss)
ssb.df=data.frame(method=c("ANCOM-BC", "ELib-UQ", "ELib-TMM", "CSS", "MED", "UQ", "TMM", "TSS"), ssb = NA)
for (i in 1:length(mds.list)) {
method=mds.list[[i]]
sst=ss_compute(method%>%dplyr::select(scale_x1, scale_x2))
ssw=ss_compute(method%>%filter(country=="MA")%>%dplyr::select(scale_x1, scale_x2))+
ss_compute(method%>%filter(country=="VEN")%>%dplyr::select(scale_x1, scale_x2))
ssb=sst-ssw
ssb.df[i, "ssb"]=ssb
}
txt.df = data.frame(X1=0.2, X2=0.25, ssb.df)
txt.df$ssb = paste0("SSB = ", round(txt.df$ssb, 0))
p.df = rbind(mds.xy.ancom.bc, mds.xy.uq1, mds.xy.tmm1, mds.xy.css,
mds.xy.med, mds.xy.uq2, mds.xy.tmm2, mds.xy.tss)
txt.df$method = factor(txt.df$method, levels = c("ANCOM-BC", "ELib-UQ", "ELib-TMM", "CSS",
"MED", "UQ", "TMM", "TSS"))
p.df$method = factor(p.df$method, levels = c("ANCOM-BC", "ELib-UQ", "ELib-TMM", "CSS",
"MED", "UQ", "TMM", "TSS"))
p=ggplot(p.df, aes(X1, X2, color = country)) + geom_point(size = 0.3) +
facet_wrap(.~method, nrow = 2)+scale_y_continuous(limits = c(-0.3, 0.3))+
labs(x="First NMDS coordinate", y="Second NMDS coordinate")+
scale_color_discrete(name="", breaks=c("MA", "VEN"), labels = c("Malawi", "Venezuela"))+
theme_bw()+
theme(plot.title = element_text(hjust = 0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "bottom",
strip.background = element_rect(fill="white"))+
guides(color = guide_legend(override.aes = list(size=3)))+
geom_text(data = txt.df, mapping = aes(x = X1, y = X2, label = ssb, color = NULL,group= NULL))
p
rm(list = ls())
library(readxl)
library(tidyverse)
library(nloptr)
library(phyloseq)
library(stringr)
library(ggpubr)
library(magrittr)
library(qwraps2)
library(pander)
panderOptions('table.caption.prefix', NULL)
panderOptions('table.continues', NULL)
panderOptions('table.emphasize.rownames', FALSE)
source("ancom_bc_v1.1.R")
ma_us_0_2=read_csv("../data/global_gut/ma_us_phylum_age2.csv")
ma_us_18_40=read_csv("../data/global_gut/ma_us_phylum_age18_40.csv")
ma_us_phyla=unique(c(ma_us_0_2$phylum, ma_us_18_40$phylum))
ma_us_0_2=ma_us_0_2%>%transmute(phylum, log.fold.change=`log fold change (MA - US)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Infants",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ma_us_phyla, ma_us_0_2$phylum))>0){
ma_us_0_2.1=data.frame(phylum=setdiff(ma_us_phyla, ma_us_0_2$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Infants", star="")
ma_us_0_2=rbind(ma_us_0_2, ma_us_0_2.1)
}
ma_us_18_40=ma_us_18_40%>%transmute(phylum, log.fold.change=`log fold change (MA - US)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Adults",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ma_us_phyla, ma_us_18_40$phylum))>0){
ma_us_18_40.1=data.frame(phylum=setdiff(ma_us_phyla, ma_us_18_40$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Adults", star="")
ma_us_18_40=rbind(ma_us_18_40, ma_us_18_40.1)
}
dat.fig_ma_us=rbind(ma_us_0_2, ma_us_18_40)
dat.fig_ma_us$age.group=factor(dat.fig_ma_us$age.group,
levels = c("Infants", "Adults"))
dat.fig_ma_us$phylum=sapply(dat.fig_ma_us$phylum, function(x) strsplit(x, "__")[[1]][2])
dat.fig_ma_us$phylum=factor(dat.fig_ma_us$phylum, levels = sort(unique(dat.fig_ma_us$phylum)))
dat.fig_ma_us$struc.zero=factor(dat.fig_ma_us$struc.zero)
ven_us_0_2=read_csv("../data/global_gut/ven_us_phylum_age2.csv")
ven_us_18_40=read_csv("../data/global_gut/ven_us_phylum_age18_40.csv")
ven_us_phyla=unique(c(ven_us_18_40$phylum, ven_us_0_2$phylum))
ven_us_0_2=ven_us_0_2%>%transmute(phylum, log.fold.change=`log fold change (VEN - US)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Infants",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ven_us_phyla, ven_us_0_2$phylum))>0){
ven_us_0_2.1=data.frame(phylum=setdiff(ven_us_phyla, ven_us_0_2$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Infants", star="")
ven_us_0_2=rbind(ven_us_0_2, ven_us_0_2.1)
}
ven_us_18_40=ven_us_18_40%>%transmute(phylum, log.fold.change=`log fold change (VEN - US)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Adults",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ven_us_phyla, ven_us_18_40$phylum))>0){
ven_us_18_40.1=data.frame(phylum=setdiff(ven_us_phyla, ven_us_18_40$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Adults", star="")
ven_us_18_40=rbind(ven_us_18_40, ven_us_18_40.1)
}
dat.fig_ven_us=rbind(ven_us_0_2, ven_us_18_40)
dat.fig_ven_us$age.group=factor(dat.fig_ven_us$age.group,
levels = c("Infants", "Adults"))
dat.fig_ven_us$phylum=sapply(dat.fig_ven_us$phylum, function(x) strsplit(x, "__")[[1]][2])
dat.fig_ven_us$phylum=factor(dat.fig_ven_us$phylum, levels = sort(unique(dat.fig_ven_us$phylum)))
dat.fig_ven_us$struc.zero=factor(dat.fig_ven_us$struc.zero)
ma_ven_0_2=read_csv("../data/global_gut/ma_ven_phylum_age2.csv")
ma_ven_18_40=read_csv("../data/global_gut/ma_ven_phylum_age18_40.csv")
ma_ven_phyla=unique(c(ma_ven_18_40$phylum, ma_ven_0_2$phylum))
ma_ven_0_2=ma_ven_0_2%>%transmute(phylum, log.fold.change=`log fold change (MA - VEN)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Infants",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ma_ven_phyla, ma_ven_0_2$phylum))>0){
ma_ven_0_2.1=data.frame(phylum=setdiff(ma_ven_phyla, ma_ven_0_2$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Infants", star="")
ma_ven_0_2=rbind(ma_ven_0_2, ma_ven_0_2.1)
}
ma_ven_18_40=ma_ven_18_40%>%transmute(phylum, log.fold.change=`log fold change (MA - VEN)`,
se=se, ci.lo=ci.lo.adj, ci.up=ci.up.adj,
struc.zero=ifelse(se==0, 1, 0),
q.val, age.group = "Adults",
star=ifelse(q.val<.001, "***",
ifelse(q.val<.01, "**",
ifelse(q.val<.05, "*", ""))))
if(length(setdiff(ma_ven_phyla, ma_ven_18_40$phylum))>0){
ma_ven_18_40.1=data.frame(phylum=setdiff(ma_ven_phyla, ma_ven_18_40$phylum),
log.fold.change=0, se=0, ci.lo=0, ci.up=0,
struc.zero=1, q.val=1, age.group="Adults", star="")
ma_ven_18_40=rbind(ma_ven_18_40, ma_ven_18_40.1)
}
dat.fig_ma_ven=rbind(ma_ven_0_2, ma_ven_18_40)
dat.fig_ma_ven$age.group=factor(dat.fig_ma_ven$age.group,
levels = c("Infants", "Adults"))
dat.fig_ma_ven$phylum=sapply(dat.fig_ma_ven$phylum, function(x) strsplit(x, "__")[[1]][2])
dat.fig_ma_ven$phylum=factor(dat.fig_ma_ven$phylum, levels = sort(unique(dat.fig_ma_ven$phylum)))
dat.fig_ma_ven$struc.zero=factor(dat.fig_ma_ven$struc.zero)
dat.fig_ma_us2=cbind(dat.fig_ma_us, type="MA - US")
dat.fig_ven_us2=cbind(dat.fig_ven_us, type="VEN - US")
dat.fig_ma_ven2=cbind(dat.fig_ma_ven, type="MA - VEN")
dat.fig_ma_ven2=dat.fig_ma_ven2[-which(dat.fig_ma_ven2$phylum%in%c("Acidobacteria", "Chloroflexi")), ]
dat.fig_ma_ven2$phylum=factor(dat.fig_ma_ven2$phylum)
dat.fig=rbind(dat.fig_ma_us2, dat.fig_ven_us2, dat.fig_ma_ven2)
dat.fig$type=factor(dat.fig$type, levels = c("MA - US", "VEN - US", "MA - VEN"))
p1=ggplot(dat.fig, aes(x=phylum, y=log.fold.change, ymin=ci.lo, ymax=ci.up, group=age.group)) +
geom_bar(aes(fill=age.group), stat="identity", width=0.4, position=position_dodge())+
geom_errorbar(width=0.2, size=0.25, position=position_dodge(width = 0.4))+
geom_abline(slope = 0, intercept = 0, linetype="dashed", alpha=0.5)+
labs(x=NULL, y="Log Fold Change")+coord_flip()+
scale_fill_discrete(name=NULL)+
scale_x_discrete(limits = rev(levels(dat.fig$phylum)))+
facet_grid(.~type, scales = "free_x")+
theme_bw()+
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill="white"))+
geom_text(aes(y=log.fold.change+4*sign(log.fold.change), label=star),
vjust=.7, color="black", position=position_dodge(width = .5))
p1 = p1+geom_point(data = dat.fig%>%filter(struc.zero==1), aes(x=phylum, y=log.fold.change),
position=position_dodge(width = 0.4), shape=18)
ggarrange(p1, labels = "a")
# Bacteroidetes - Firmicutes
BFratio_summary = function(eval_data, country, age){
BFdiff=eval_data%>%dplyr::select(phylum, log.fold.change, se)%>%
filter(phylum%in%c("p__Bacteroidetes", "p__Firmicutes"))
diff_mean=BFdiff%>%filter(phylum == "p__Bacteroidetes")%>%.$log.fold.change-
BFdiff%>%filter(phylum == "p__Firmicutes")%>%.$log.fold.change
diff_se=sqrt(BFdiff%>%filter(phylum == "p__Bacteroidetes")%>%.$se%>%.^2+
BFdiff%>%filter(phylum == "p__Firmicutes")%>%.$se%>%.^2)
diff_p=2*pnorm(abs(diff_mean/diff_se), mean=0, sd=1, lower.tail = F)
ci_lo=diff_mean-1.96*diff_se
ci_up=diff_mean+1.96*diff_se
BFdiff=signif(c(diff_mean, diff_se, diff_p, ci_lo, ci_up), 2)
BFdiff=c(country, age, BFdiff)
return(BFdiff)
}
country.list = rep(c("MA - US", "VEN - US", "MA - VEN"), 2)
age.list = rep(c("Infants", "Adults"), each = 3)
eval.data.list = list(ma_us_0_2, ven_us_0_2, ma_ven_0_2, ma_us_18_40, ven_us_18_40, ma_ven_18_40)
BFres.list = vector(mode = "list", length = 6)
for (i in 1:6) {
country = country.list[i]
age = age.list[i]
eval.data = eval.data.list[[i]]
BFres.list[[i]] = BFratio_summary(eval.data, country, age)
}
BFres = as.data.frame(Reduce('rbind', BFres.list), stringsAsFactors = F)
rownames(BFres)=NULL
colnames(BFres)=c("country", "age", "log.fold.change", "se", "p.value", "ci.lo", "ci.up")
BFres$age = factor(BFres$age, levels = c("Infants", "Adults"))
dat.fig.diff=BFres
dat.fig.diff$log.fold.change=as.numeric(dat.fig.diff$log.fold.change)
dat.fig.diff$ci.lo=as.numeric(dat.fig.diff$ci.lo)
dat.fig.diff$ci.up=as.numeric(dat.fig.diff$ci.up)
dat.fig.diff$p.value=as.numeric(dat.fig.diff$p.value)
dat.fig.diff=dat.fig.diff%>%mutate(star=ifelse(p.value<.001, "***",
ifelse(p.value<.01, "**",
ifelse(p.value<.05, "*", ""))))
p2=ggplot(dat.fig.diff, aes(x=country, y=log.fold.change, ymin=ci.lo, ymax=ci.up, group=age)) +
geom_bar(aes(fill=age),
stat="identity", width=0.4, position=position_dodge())+
geom_errorbar(width=.2, size=.25, position=position_dodge(width = .4))+
geom_abline(slope = 0, intercept = 0, linetype="dashed", alpha=0.5)+
labs(x=NULL, y="Log Fold Change (Bacteroidetes - Firmicutes)")+coord_flip()+
scale_fill_discrete(name="")+
scale_x_discrete(limits = c("MA - VEN", "VEN - US", "MA - US"))+
theme_bw()+
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"))+
geom_text(aes(y=log.fold.change+2.5*sign(log.fold.change), label=star),
vjust=.7, color="black", position=position_dodge(width = .5))
ggarrange(p2, labels = "b")
library(tidyverse)
source("sim_data_poi_gam_two_grp.R")
source("ancom_bc_v1.0.R")
library(tidyverse)
source("scripts/sim_data_poi_gam_two_grp.R")
source("scripts/ancom_bc_v1.0.R")
# The number of taxa, library size, and sample size
n.taxa = 1000; balanced.micro.load = FALSE; balanced.lib.size = TRUE
samp.frac = "small"; n.samp = "20_30"
# The proportion of differentially abundant taxa
prop.diff=c(0.05, 0.15, 0.25, 0.50, 0.75)
# Set seeds
iterNum=100
abn.seed=seq(iterNum)
# Define the simulation parameters
simparams=expand.grid(n.taxa, n.samp, prop.diff, abn.seed,
balanced.micro.load, balanced.lib.size, samp.frac)
colnames(simparams)=c("n.taxa", "n.samp", "prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac")
simparams=simparams%>%mutate(obs.seed=abn.seed+1)
simparams=simparams%>%separate(col = n.samp, into = c("n.samp.grp1", "n.samp.grp2"), sep = "_")
simparams=simparams%>%arrange(n.taxa, n.samp.grp1, prop.diff, abn.seed, obs.seed)
simparams.list=apply(simparams, 1, paste0, collapse="_")
simparamslabels=c("n.taxa", "n.samp.grp1", "n.samp.grp2","prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac", "obs.seed")
library(doParallel)
library(foreach)
View(simparams)
i = simparams.list[[1]]
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
obs.abn=test.dat$obs.abn
meta.data=cbind(Sample.ID=paste0("sub", seq(n.samp.grp1+n.samp.grp2)),
group=rep(c(1, 2), c(n.samp.grp1, n.samp.grp2)))
# Pre-processing
feature.table=obs.abn; sample.var="Sample.ID"; group.var="group"
zero.cut=0.90; lib.cut=1000; neg.lb=FALSE
pre.process=feature_table_pre_process(feature.table, meta.data, sample.var,
group.var, zero.cut, lib.cut, neg.lb)
feature.table=pre.process$feature.table
group.name=pre.process$group.name
group.ind=pre.process$group.ind
struc.zero=pre.process$structure.zeros
# Paras for ANCOM-BC
grp.name=group.name; grp.ind=group.ind; adj.method="bonferroni"
tol.EM=1e-5; max.iterNum=100; perNum=1000; alpha=0.05
# Run ANCOM-BC
suppressWarnings(out <- try(ANCOM_BC(feature.table, grp.name, grp.ind, struc.zero,
adj.method, tol.EM, max.iterNum, perNum, alpha),
silent = TRUE))
bias.em=out$bias.est; bias.wls=out$bias.wls; bias.diff=bias.em-bias.wls
c(bias.em, bias.wls, bias.diff)
bias.em=out$bias.est[2]; bias.wls=out$bias.wls[2]; bias.diff=bias.em-bias.wls
c(bias.em, bias.wls, bias.diff)
n.taxa.raw = nrow(feature.table)
taxa.id.raw = rownames(feature.table)
n.samp = ncol(feature.table)
sample.id = colnames(feature.table)
n.grp = length(grp.ind)
n.samp.grp = sapply(grp.ind, length)
### 0. Discard taxa with structural zeros for the moment
comp.taxa.pos = which(apply(struc.zero, 1, function(x) all(x == 0))) # position of complete taxa (no structural zeros)
O = feature.table[comp.taxa.pos, ]
n.taxa = nrow(O)
taxa.id = rownames(O)
n.samp = ncol(O)
y = as.matrix(log(O + 1))
### 1. Initial estimates of sampling fractions and mean absulute abundances
mu = t(apply(y, 1, function(i) tapply(i, rep(1:n.grp, n.samp.grp), function(j)
mean(j, na.rm = T))))
d = colMeans(y - mu[, rep(1:n.grp, times = n.samp.grp)], na.rm = T)
## Iteration in case of missing values of y
iterNum = 0
epsilon = 100
while (epsilon > tol.EM & iterNum < max.iterNum) {
# Updating mu
mu.new = t(apply(t(t(y) - d), 1, function(i) tapply(i, rep(1:n.grp, n.samp.grp), function(j)
mean(j, na.rm = T))))
# Updating d
d.new = colMeans(y - mu.new[, rep(1:ncol(mu.new), times = n.samp.grp)], na.rm = T)
# Iteration
epsilon = sqrt(sum((mu.new - mu)^2) + sum((d.new - d)^2))
iterNum = iterNum + 1
mu = mu.new
d = d.new
}
mu.var.each = (y-t(t(mu[, rep(1:ncol(mu), times = n.samp.grp)])+d))^2
mu.var = t(apply(mu.var.each, 1, function(x) tapply(x, rep(1:n.grp, n.samp.grp), function(y)
mean(y, na.rm = T))))
sample.size = t(apply(y, 1, function(x)
unlist(tapply(x, rep(1:n.grp, n.samp.grp), function(y) length(y[!is.na(y)])))))
mu.var = mu.var/sample.size
### 2. Estimate the bias (between-group difference of sampling fractions) by E-M algorithm
bias.em.vec = rep(NA, n.grp - 1)
bias.wls.vec = rep(NA, n.grp - 1)
bias.var.vec = rep(NA, n.grp - 1)
for (i in 1:(n.grp-1)) {
Delta = mu[, 1] - mu[, 1+i]
nu = rowSums(mu.var[, c(1, 1+i)])
## 2.1 Initials
pi0_0 = 0.75
pi1_0 = 0.125
pi2_0 = 0.125
delta_0 = mean(Delta[Delta >= quantile(Delta, 0.25, na.rm = T)&
Delta <= quantile(Delta, 0.75, na.rm = T)], na.rm = T)
l1_0 = mean(Delta[Delta < quantile(Delta, 0.125, na.rm = T)], na.rm = T)
l2_0 = mean(Delta[Delta > quantile(Delta, 0.875, na.rm = T)], na.rm = T)
kappa1_0 = var(Delta[Delta < quantile(Delta, 0.125, na.rm = T)], na.rm = T)
if(is.na(kappa1_0)|kappa1_0 == 0) kappa1_0 = 1
kappa2_0 = var(Delta[Delta > quantile(Delta, 0.875, na.rm = T)], na.rm = T)
if(is.na(kappa2_0)|kappa2_0 == 0) kappa2_0 = 1
## 2.2 Apply E-M algorithm
# 2.21 Store all paras in vectors/matrices
pi0.vec = c(pi0_0); pi1.vec = c(pi1_0); pi2.vec = c(pi2_0)
delta.vec = c(delta_0); l1.vec = c(l1_0); l2.vec = c(l2_0)
kappa1.vec = c(kappa1_0); kappa2.vec = c(kappa2_0)
# 2.22 E-M iteration
iterNum = 0
epsilon = 100
while (epsilon > tol.EM & iterNum < max.iterNum) {
# print(iterNum)
## Current value of paras
pi0 = pi0.vec[length(pi0.vec)]; pi1 = pi1.vec[length(pi1.vec)]; pi2 = pi2.vec[length(pi2.vec)]
delta = delta.vec[length(delta.vec)];
l1 = l1.vec[length(l1.vec)]; l2 = l2.vec[length(l2.vec)]
kappa1 = kappa1.vec[length(kappa1.vec)]; kappa2 = kappa2.vec[length(kappa2.vec)]
## E-step
pdf0 = sapply(seq(n.taxa), function(i) dnorm(Delta[i], delta, sqrt(nu[i])))
pdf1 = sapply(seq(n.taxa), function(i) dnorm(Delta[i], delta + l1, sqrt(nu[i] + kappa1)))
pdf2 = sapply(seq(n.taxa), function(i) dnorm(Delta[i], delta + l2, sqrt(nu[i] + kappa2)))
r0i = pi0*pdf0/(pi0*pdf0 + pi1*pdf1 + pi2*pdf2); r0i[is.na(r0i)] = 0
r1i = pi1*pdf1/(pi0*pdf0 + pi1*pdf1 + pi2*pdf2); r1i[is.na(r1i)] = 0
r2i = pi2*pdf2/(pi0*pdf0 + pi1*pdf1 + pi2*pdf2); r2i[is.na(r2i)] = 0
## M-step
pi0_new = mean(r0i, na.rm = T); pi1_new = mean(r1i, na.rm = T); pi2_new = mean(r2i, na.rm = T)
delta_new = sum(r0i*Delta/nu + r1i*(Delta-l1)/(nu+kappa1) + r2i*(Delta-l2)/(nu+kappa2), na.rm = T)/
sum(r0i/nu + r1i/(nu+kappa1) + r2i/(nu+kappa2), na.rm = T)
l1_new = min(sum(r1i*(Delta-delta)/(nu+kappa1), na.rm = T)/sum(r1i/(nu+kappa1), na.rm = T), 0)
l2_new = max(sum(r2i*(Delta-delta)/(nu+kappa2), na.rm = T)/sum(r2i/(nu+kappa2), na.rm = T), 0)
# Nelder-Mead simplex algorithm for kappa1 and kappa2
obj.kappa1 = function(x){
log.pdf = log(sapply(seq(n.taxa), function(i) dnorm(Delta[i], delta+l1, sqrt(nu[i]+x))))
log.pdf[is.infinite(log.pdf)] = 0
-sum(r1i*log.pdf, na.rm = T)
}
kappa1_new = neldermead(x0 = kappa1, fn = obj.kappa1, lower = 0)$par
obj.kappa2 = function(x){
log.pdf = log(sapply(seq(n.taxa), function(i) dnorm(Delta[i], delta+l2, sqrt(nu[i]+x))))
log.pdf[is.infinite(log.pdf)] = 0
-sum(r2i*log.pdf, na.rm = T)
}
kappa2_new = neldermead(x0 = kappa2, fn = obj.kappa2, lower = 0)$par
## Merge to the paras vectors/matrices
pi0.vec = c(pi0.vec, pi0_new); pi1.vec = c(pi1.vec, pi1_new); pi2.vec = c(pi2.vec, pi2_new)
delta.vec = c(delta.vec, delta_new)
l1.vec = c(l1.vec, l1_new); l2.vec = c(l2.vec, l2_new)
kappa1.vec = c(kappa1.vec, kappa1_new); kappa2.vec = c(kappa2.vec, kappa2_new)
## Calculate the new epsilon
epsilon = sqrt((pi0_new-pi0)^2 + (pi1_new-pi1)^2 + (pi2_new-pi2)^2 + (delta_new-delta)^2+
(l1_new-l1)^2 + (l2_new-l2)^2 + (kappa1_new-kappa1)^2 + (kappa2_new-kappa2)^2)
iterNum = iterNum+1
}
# 2.23 Estimate the bias
bias.em.vec[i] = delta.vec[length(delta.vec)]
# 2.24 The WLS estimator of bias
# Cluster 0
C0 = which(Delta >= quantile(Delta, pi1_new, na.rm = T) & Delta < quantile(Delta, 1 - pi2_new, na.rm = T))
# Cluster 1
C1 = which(Delta < quantile(Delta, pi1_new, na.rm = T))
# Cluster 2
C2 = which(Delta >= quantile(Delta, 1 - pi2_new, na.rm = T))
wls.deno = nu
wls.deno[C1] = wls.deno[C1] + kappa1_new; wls.deno[C2] = wls.deno[C2] + kappa2_new
wls.deno = 1 / wls.deno
wls.nume = wls.deno
wls.nume[C0] = (wls.nume * Delta)[C0]
wls.nume[C1] = (wls.nume * (Delta - l1_new))[C1]; wls.nume[C2] = (wls.nume * (Delta - l2_new))[C2];
bias.wls.vec[i] = wls.nume / wls.deno
# 2.25 Estimate the variance of bias
bias.var.vec[i] = 1 / wls.deno
if (is.na(bias.var.vec[i])) bias.var.vec[i] = 0
}
bias.em.vec = c(0, bias.em.vec)
bias.wls.vec = c(0, bias.wls.vec)
wls.deno = nu
wls.deno[C1] = wls.deno[C1] + kappa1_new; wls.deno[C2] = wls.deno[C2] + kappa2_new
wls.deno = sum(1 / wls.deno)
wls.nume = wls.deno
wls.nume[C0] = (wls.nume * Delta)[C0]
wls.nume[C1] = (wls.nume * (Delta - l1_new))[C1]; wls.nume[C2] = (wls.nume * (Delta - l2_new))[C2];
wls.nume = sum(wls.nume)
bias.wls.vec[i] = wls.nume / wls.deno
# 2.25 Estimate the variance of bias
bias.var.vec[i] = sum(1 / wls.deno)
if (is.na(bias.var.vec[i])) bias.var.vec[i] = 0
bias.wls.vec = c(0, bias.wls.vec)
bias.em.vec = c(0, bias.em.vec)
bias.em.vec
bias.wls.vec
wls.deno = nu
wls.deno[C1] = wls.deno[C1] + kappa1_new; wls.deno[C2] = wls.deno[C2] + kappa2_new
wls.deno = sum(1 / wls.deno)
wls.deno
# 2.25 Estimate the variance of bias
bias.var.vec[i] = 1 / sum(1 / wls.deno)
bias.var.vec
1 / sum(1 / wls.deno)
wls.deno = nu
wls.deno[C1] = wls.deno[C1] + kappa1_new; wls.deno[C2] = wls.deno[C2] + kappa2_new
wls.deno = sum(1 / wls.deno)
wls.deno
# 2.25 Estimate the variance of bias
bias.var.vec[i] = 1 / wls.deno
bias.var.vec
wls.nume = wls.deno
nu_temp = nu
nu_temp[C1] = nu_temp[C1] + kappa1_new; nu_temp[C2] = nu_temp[C2] + kappa2_new
wls.deno = sum(1 / nu_temp)
wls.deno
wls.nume = 1 / nu_temp
wls.nume[C0] = (wls.nume * Delta)[C0]
wls.nume[C1] = (wls.nume * (Delta - l1_new))[C1]; wls.nume[C2] = (wls.nume * (Delta - l2_new))[C2];
wls.nume = sum(wls.nume)
wls.nume / wls.deno
1 / wls.deno
source("scripts/ancom_bc_v1.0.R")
# Run ANCOM-BC
suppressWarnings(out <- try(ANCOM_BC(feature.table, grp.name, grp.ind, struc.zero,
adj.method, tol.EM, max.iterNum, perNum, alpha),
silent = TRUE))
if (inherits(out, "try-error")) {
bias.em=NA; bias.wls=NA; bias.diff=NA
}else{
bias.em=out$bias.est[2]; bias.wls=out$bias.wls[2]; bias.diff=bias.em-bias.wls
}
c(bias.em, bias.wls, bias.diff)
rm(list = ls())
library(readr)
library(microbiome)
source("ancom_bc_v1.0.R")
data(dietswap)
pseq = dietswap
n_taxa = ntaxa(pseq)
n_samp = nsamples(pseq)
# Metadata
meta_data = meta(pseq)
# Taxonomy table
taxonomy = tax_table(pseq)
# Absolute abundances
otu_absolute = abundances(pseq)
# Pre-processing
feature.table = otu_absolute; sample.var = "sample"; group.var = "nationality";
zero.cut = 0.90; lib.cut = 1000; neg.lb = TRUE
pre.process = feature_table_pre_process(feature.table, meta_data, sample.var,
group.var, zero.cut, lib.cut, neg.lb)
feature.table = pre.process$feature.table
group.name = pre.process$group.name
group.ind = pre.process$group.ind
struc.zero = pre.process$structure.zeros
# Paras for ANCOM-BC
grp.name = group.name; grp.ind = group.ind; adj.method = "bonferroni"
tol.EM = 1e-5; max.iterNum = 100; perNum = 1000; alpha = 0.05
out = ANCOM_BC(feature.table, grp.name, grp.ind, struc.zero,
adj.method, tol.EM, max.iterNum, perNum, alpha)
res = cbind(taxon = rownames(out$feature.table), out$res)
View(res)
