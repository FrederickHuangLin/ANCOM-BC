res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
View(countdata)
View(feature_table)
DESeq(count.table, quiet = TRUE)
library(DESeq2)
library(doParallel)
library(foreach)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
i = simparams.list[[2]]
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for DESeq2
countdata=test.dat$obs.abn # Format for DESeq2: taxa are rows
coldata=data.frame(group=as.factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2))))
rownames(coldata)=paste0("sub", seq(n.samp.grp1+n.samp.grp2))
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
feature_table=round(countdata[which(taxa.info.ind<zero.threshold), ])+1L
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
# The number of taxa, library size, and sample size
n.taxa = 1000; balanced.micro.load = FALSE; balanced.lib.size = TRUE
samp.frac = "small"; n.samp = c("20_30", "50_50")
# The proportion of differentially abundant taxa
prop.diff=c(0.50, 0.75)
# Set seeds
iterNum=100
abn.seed=seq(iterNum)
# Define the simulation parameters
simparams=expand.grid(n.taxa, n.samp, prop.diff, abn.seed,
balanced.micro.load, balanced.lib.size, samp.frac)
colnames(simparams)=c("n.taxa", "n.samp", "prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac")
simparams=simparams%>%mutate(obs.seed=abn.seed+1)
simparams=simparams%>%separate(col = n.samp, into = c("n.samp.grp1", "n.samp.grp2"), sep = "_")
simparams=simparams%>%arrange(n.taxa, n.samp.grp1, prop.diff, abn.seed, obs.seed)
simparams.list=apply(simparams, 1, paste0, collapse="_")
simparamslabels=c("n.taxa", "n.samp.grp1", "n.samp.grp2","prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac", "obs.seed")
i = simparams.list[[1]]
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for DESeq2
countdata=test.dat$obs.abn # Format for DESeq2: taxa are rows
coldata=data.frame(group=as.factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2))))
rownames(coldata)=paste0("sub", seq(n.samp.grp1+n.samp.grp2))
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
feature_table=round(countdata[which(taxa.info.ind<zero.threshold), ])+1L
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for edgeR
groupdata=factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2)))
countdata=test.dat$obs.abn; meta.data=data.frame(group=groupdata)
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
countdata=countdata[which(taxa.info.ind<zero.threshold), ]+1L
d=DGEList(counts = countdata, group = groupdata)
d=calcNormFactors(d)
design.mat=model.matrix(~ 0 + d$samples$group)
colnames(design.mat)=levels(d$samples$group)
d=estimateDisp(d, design.mat)
fit=glmQLFit(d, design.mat)
qlf=glmQLFTest(fit, contrast=c(1, -1))
out=data.frame(taxa=rownames(topTags(qlf, n=nrow(countdata))$table),
FDR=topTags(qlf, n=nrow(countdata))$table$FDR)
out=out[match(rownames(countdata), as.character(out$taxa)), ]
out$FDR[is.na(out$FDR)]=1
res=data.frame(diff.test=ifelse(out$FDR<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)])
# FDR
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
# Power
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
c(FDR, power)
library(edgeR)
# Prepare data for edgeR
groupdata=factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2)))
countdata=test.dat$obs.abn; meta.data=data.frame(group=groupdata)
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
countdata=countdata[which(taxa.info.ind<zero.threshold), ]+1L
d=DGEList(counts = countdata, group = groupdata)
d=calcNormFactors(d)
design.mat=model.matrix(~ 0 + d$samples$group)
colnames(design.mat)=levels(d$samples$group)
d=estimateDisp(d, design.mat)
fit=glmQLFit(d, design.mat)
qlf=glmQLFTest(fit, contrast=c(1, -1))
out=data.frame(taxa=rownames(topTags(qlf, n=nrow(countdata))$table),
FDR=topTags(qlf, n=nrow(countdata))$table$FDR)
out=out[match(rownames(countdata), as.character(out$taxa)), ]
out$FDR[is.na(out$FDR)]=1
res=data.frame(diff.test=ifelse(out$FDR<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)])
# FDR
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
# Power
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
c(FDR, power)
# The number of taxa, library size, and sample size
n.taxa=1000; balanced.micro.load = FALSE; balanced.lib.size = TRUE
samp.frac = "small"; n.samp=c("5_5", "10_10")
# The proportion of differentially abundant taxa
prop.diff=c(0.05, 0.15, 0.25)
# Set seeds
iterNum=100
abn.seed=seq(iterNum)
# Define the simulation parameters
simparams=expand.grid(n.taxa, n.samp, prop.diff, abn.seed,
balanced.micro.load, balanced.lib.size, samp.frac)
colnames(simparams)=c("n.taxa", "n.samp", "prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac")
simparams=simparams%>%mutate(obs.seed=abn.seed+1)
simparams=simparams%>%separate(col = n.samp, into = c("n.samp.grp1", "n.samp.grp2"), sep = "_")
simparams=simparams%>%arrange(n.taxa, n.samp.grp1, prop.diff, abn.seed, obs.seed)
simparams.list=apply(simparams, 1, paste0, collapse="_")
simparamslabels=c("n.taxa", "n.samp.grp1", "n.samp.grp2","prop.diff", "abn.seed",
"balanced.micro.load", "balanced.lib.size", "samp.frac", "obs.seed")
i = simparams.list[[1]]
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for DESeq2
countdata=test.dat$obs.abn # Format for DESeq2: taxa are rows
coldata=data.frame(group=as.factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2))))
rownames(coldata)=paste0("sub", seq(n.samp.grp1+n.samp.grp2))
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
feature_table=round(countdata[which(taxa.info.ind<zero.threshold), ])+1L
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
library(DESeq2)
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for DESeq2
countdata=test.dat$obs.abn # Format for DESeq2: taxa are rows
coldata=data.frame(group=as.factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2))))
rownames(coldata)=paste0("sub", seq(n.samp.grp1+n.samp.grp2))
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
feature_table=round(countdata[which(taxa.info.ind<zero.threshold), ])+1L
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
source("scripts/sim_data_poi_gam_two_grp.R")
print(i)
params = strsplit(i, "_")[[1]]
names(params) <- simparamslabels
# Paras for data generation
n.taxa=as.numeric(params["n.taxa"])
n.samp.grp1=as.numeric(params["n.samp.grp1"])
n.samp.grp2=as.numeric(params["n.samp.grp2"])
prop.diff=as.numeric(params["prop.diff"])
abn.seed=as.numeric(params["abn.seed"])
obs.seed=as.numeric(params["obs.seed"])
balanced.micro.load=as.logical(params["balanced.micro.load"])
balanced.lib.size=as.logical(params["balanced.lib.size"])
samp.frac=params["samp.frac"]
# Data generation
low.abn=50; med.abn=200; high.abn=10000; struc.zero.prop=0.20; out.zero.prop=0.05
test.dat=abn.tab.gen1(n.taxa, n.samp.grp1, n.samp.grp2, low.abn, med.abn, high.abn,
prop.diff, abn.seed, obs.seed, struc.zero.prop, out.zero.prop,
balanced.micro.load, balanced.lib.size, samp.frac)
# Prepare data for DESeq2
countdata=test.dat$obs.abn # Format for DESeq2: taxa are rows
coldata=data.frame(group=as.factor(rep(c(1, 2), c(n.samp.grp1, n.samp.grp2))))
rownames(coldata)=paste0("sub", seq(n.samp.grp1+n.samp.grp2))
zero.threshold=0.90
taxa.info.ind=apply(countdata, 1, function(x) sum(x==0)/(n.samp.grp1+n.samp.grp2))
feature_table=round(countdata[which(taxa.info.ind<zero.threshold), ])+1L
count.table=DESeqDataSetFromMatrix(
countData = feature_table, colData = coldata, design = ~ group)
# Run DESeq2
suppressWarnings(dds <- try(DESeq(count.table, quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If the parametric fit failed, try the local.
suppressWarnings(dds <- try(DESeq(count.table, fitType = "local", quiet = TRUE), silent = TRUE))
if (inherits(dds, "try-error")) {
# If local fails, try the mean
suppressWarnings(dds <- try(DESeq(count.table, fitType = "mean", quiet = TRUE), silent = TRUE))
}
}
if (inherits(dds, "try-error")) {
# If still bad
FDR=NA; power=NA
}else{
res = results(dds)
res$id = rownames(res)
# Some DESeq2 results (for example) had NA adjusted p-values, so replace them with 1
res[is.na(res[, "padj"]), "padj"] = 1
res=data.frame(taxa=res$id,
diff.test=ifelse(res$padj<0.05, 1, 0),
diff.ind=test.dat$diff.taxa[which(taxa.info.ind<zero.threshold)],
effec.size=test.dat$effect.size[which(taxa.info.ind<zero.threshold)])
FDR=ifelse(sum(res$diff.test==1, na.rm = T)==0, 0,
sum(ifelse(res$diff.ind==0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.test==1, na.rm = T))
power=sum(ifelse(res$diff.ind!=0&res$diff.test==1, 1, 0), na.rm = T)/
sum(res$diff.ind!=0, na.rm = T)
}
c(FDR, power)
rm(list = ls())
library(tidyverse)
library(nloptr)
library(phyloseq)
library(stringr)
library(RColorBrewer)
library(ggpubr)
library(ggforce)
library(limma)
library(vegan)
library(MASS)
library(pander)
panderOptions('table.caption.prefix', NULL)
panderOptions('table.continues', NULL)
panderOptions('table.emphasize.rownames', FALSE)
source("ancom_bc_v1.0.R")
source("ancom_v1.0.R")
txt.df = read_csv("../data/global_gut/ssb.csv")
p.df = read_csv("../data/global_gut/nmds.csv")
txt.df$method = factor(txt.df$method, levels = c("ANCOM-BC", "ELib-UQ", "ELib-TMM", "CSS",
"MED", "UQ", "TMM", "TSS"))
p.df$method = factor(p.df$method, levels = c("ANCOM-BC", "ELib-UQ", "ELib-TMM", "CSS",
"MED", "UQ", "TMM", "TSS"))
p=ggplot(p.df, aes(X1, X2, color = country)) + geom_point(size = 0.3) +
facet_wrap(.~method, nrow = 2)+scale_y_continuous(limits = c(-0.3, 0.3))+
labs(x="First NMDS coordinate", y="Second NMDS coordinate")+
scale_color_discrete(name="", breaks=c("MA", "VEN"), labels = c("Malawi", "Venezuela"))+
theme_bw()+
theme(plot.title = element_text(hjust = 0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "bottom",
strip.background = element_rect(fill="white"))+
guides(color = guide_legend(override.aes = list(size=3)))+
geom_text(data = txt.df, mapping = aes(x = X1, y = X2, label = ssb, color = NULL,group= NULL))
p
